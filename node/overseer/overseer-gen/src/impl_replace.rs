//! Replace a subsystem
use proc_macro2::{Span, TokenStream};
use quote::quote;
use std::collections::HashSet;

use quote::ToTokens;
use syn::AttrStyle;
use syn::Field;
use syn::FieldsNamed;
use syn::Variant;
use syn::{parse2, Attribute, Error, GenericParam, Ident, PathArguments, Result, Type, TypeParam, WhereClause};

use super::*;

pub(crate) fn impl_replacable_subsystem(
	name: Ident,
	subsystems: &[SubSysField],
	baggage: &[BaggageField],
) -> Result<proc_macro2::TokenStream> {
	let msg = "Generated by #[overlord] derive proc-macro.";

	let span = Span::call_site();

	let mut field_name = &subsystems.iter().map(|x| x.name.clone()).collect::<Vec<_>>();
	let mut field_ty = &subsystems.iter().map(|x| x.generic.clone()).collect::<Vec<_>>();

	let mut baggage_generic_ty = &baggage.iter().filter(|b| b.generic).map(|b| b.field_ty.clone()).collect::<Vec<_>>();

	let mut baggage_name = &baggage.iter().map(|x| x.field_name.clone()).collect::<Vec<_>>();

	let generics = quote! {
		< Ctx: SubsystemContext, #( #baggage_generic_ty, )* #( #field_ty, )* >
	};

	let where_clause = quote! {
		where
			#( #field_ty : Subsystem<Ctx>, )*
	};

	let mut additive = TokenStream::new();

	// generate an impl of `fn replace_#name`
	for SubSysField { name: replacable_item, ty: replacable_item_ty, generic, .. } in subsystems {
		let keeper = subsystems.iter().filter(|&ssf| ssf.generic != *generic).map(|ssf| ssf.name.clone());

		let fn_name = Ident::new(&format!("replace_{}", replacable_item), span);
		// adjust the generics such that the appropriate member type is replaced

		let new = Ident::new("NEW", span);
		let modified_generics = &subsystems
			.iter()
			.map(|ssf| if ssf.generic != *generic { ssf.generic.clone() } else { new.clone() })
			.collect::<Vec<_>>();

		let modified_generics = quote! {
			< Ctx, #( #baggage_generic_ty, )* #( #modified_generics, )* >
		};

		let x: TokenStream = quote! {
			impl #generics #name #generics #where_clause {
				#[doc = #msg]
				pub fn #fn_name < #new > (self, replacement: #new) -> #name #modified_generics
					where
						#new: Subsystem<Ctx>
				{
					#name :: #modified_generics {
						#replacable_item: replacement,
						#(
							#keeper: self.#keeper,
						)*
						#(
							#baggage_name: self.#baggage_name,
						)*
					}
				}
			}
		};
		additive.extend(x);
	}

	Ok(additive)
}
