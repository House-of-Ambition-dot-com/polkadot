use proc_macro2::{Span, TokenStream};
use quote::quote;
use std::collections::HashSet;

use quote::ToTokens;
use syn::AttrStyle;
use syn::Generics;
use syn::Field;
use syn::FieldsNamed;
use syn::Variant;
use syn::{parse2, Attribute, Error, GenericParam, Ident, PathArguments, Result, Type, TypeParam, WhereClause};
use syn::spanned::Spanned;

use super::*;


#[derive(Clone)]
pub(crate) struct SubSysField {
	/// Name of the field.
	pub(crate) name: Ident,
	/// Generate generic type name for the `AllSubsystems` type.
	pub(crate) generic: Ident,
	/// Type of the subsystem.
	pub(crate) ty: Ident,
	/// Type to be consumed by the subsystem.
	pub(crate) consumes: Vec<Ident>,
	/// Consumes is a set of messages, are these to be dispatched?
	pub(crate) no_dispatch: bool,
}

fn try_type_to_ident(ty: Type, span: Span) -> Result<Ident> {
	match ty {
		Type::Path(path) => {
			path.path.get_ident().cloned().ok_or_else(|| Error::new(span, "Expected an identifier, but got a path."))
		}
		_ => Err(Error::new(span, "Type must be a path expression.")),
	}
}

pub(crate) struct AttrArgs {
	pub(crate) wrapper_enum_name: Ident,
	pub(crate) signal_capacity: usize,
	pub(crate) message_capacity: usize,
}

fn parse_attr(_attr: TokenStream) -> Result<AttrArgs> {
	Ok(AttrArgs {
		wrapper_enum_name: Ident::new("AllMessages", Span::call_site()),
		signal_capacity: 64usize,
		message_capacity: 1024usize,
	})
}

use syn::parse::Parse;
use syn::punctuated::Punctuated;
use syn::token::Paren;
use syn::Token;


pub(crate) struct SubSystemTag {
	pub(crate) attrs: Vec<Attribute>,
	pub(crate) paren_token: Paren,
	pub(crate) no_dispatch: bool,
	pub(crate) consumes: Punctuated<Ident, Token![|]>,
}

impl Parse for SubSystemTag {
	fn parse(input: syn::parse::ParseStream) -> Result<Self> {
		let content;
		Ok(Self {
			attrs: Attribute::parse_outer(input)?,
			paren_token: syn::parenthesized!(content in input),
			no_dispatch: false, // FIXME
			consumes: content.parse_terminated(Ident::parse)?,
		})
	}
}

/// Creates a list of generic identifiers used for the subsystems
pub(crate) fn parse_overseer_struct_field(
	baggage_generics: HashSet<Ident>,
	fields: FieldsNamed,
) -> Result<(Vec<SubSysField>, Vec<BaggageField>)> {
	let span = Span::call_site();
	let n = fields.named.len();
	let mut subsystems = Vec::with_capacity(n);
	let mut baggage = Vec::with_capacity(n);
	for (idx, Field { attrs, vis, ident, ty, .. }) in fields.named.into_iter().enumerate() {
		let mut consumes = attrs.iter().filter(|attr| attr.style == AttrStyle::Outer).filter_map(|attr| {
			let span = attr.path.span();
			attr.path.get_ident().filter(|ident| *ident == "subsystem").map(move |_ident| {
				let attr_tokens = attr.tokens.clone();
				(attr_tokens, span)
			})
		});
		let ident = ident.ok_or_else(|| {
			Error::new(ty.span(), "Missing identifier for member. BUG")
		})?;

		if let Some((attr_tokens, span)) = consumes.next() {
			if let Some((attr_tokens2, span2)) = consumes.next() {
				return Err({
					let mut err = Error::new(span, "The first subsystem annotation is at");
					err.combine(
							Error::new(span2, "but another here for the same field.")
						);
					err
				})
			}
			let mut consumes_idents = Vec::with_capacity(attrs.len());

			let variant = syn::parse2::<SubSystemTag>(dbg!(attr_tokens.clone()))?;
			consumes_idents.extend(variant.consumes.into_iter());

			if consumes_idents.is_empty() {
				return Err(
					Error::new(span, "Subsystem must consume at least one message")
				)
			}
			let no_dispatch = variant.no_dispatch;

			subsystems.push(SubSysField {
				name: ident,
				generic: Ident::new(format!("Sub{}", idx).as_str(), Span::call_site()),
				ty: try_type_to_ident(ty, span)?,
				consumes: consumes_idents,
				no_dispatch,
			});
		} else {
			let field_ty = try_type_to_ident(ty, Span::call_site())?;
			baggage.push(BaggageField {
				field_name: ident,
				generic: !baggage_generics.contains(&field_ty),
				field_ty,
			});
		}
	}
	Ok((subsystems, baggage))
}


// /// Extend the originally provided `Generics` with those generated by the subsystems,
// /// namely `Sub#N`, plus one more `Ctx` which is generic over the subsystem context to use.
// pub(crate) fn extra_generics_combine_generics(
// 	orig_generics: &Generics,
// 	subsystems: &[SubSysField],
// ) -> Result<Generics> {
// 	let mut combined_generics = orig_generics.clone();

// 	let mut ctx_generic = GenericParam::Type(
// 		syn::parse2::<TypeParam>(quote! {
// 			Ctx: SubsystemContext,
// 		})
// 		.unwrap(),
// 	);

// 	let mut subsys_generics = subsystems.iter().map(|ssf| {
// 		let subsys_generic_name = ssf.generic.clone();
// 		GenericParam::Type(
// 			syn::parse2::<TypeParam>(quote! {
// 				#subsys_generic_name: Subsystem<Ctx>,
// 			})
// 			.unwrap(),
// 		)
// 	});
// 	combined_generics.params.extend(Some(ctx_generic));
// 	combined_generics.params.extend(subsys_generics);
// 	Ok(combined_generics)
// }

/// Fields that are _not_ subsystems.
pub(crate) struct BaggageField {
	pub(crate) field_name: Ident,
	pub(crate) field_ty: Ident,
	pub(crate) generic: bool,
}

/// Generates the wrapper type enum.
pub(crate) fn impl_messages_wrapper_enum(
	messages_wrapper: Ident,
	subsystems: &[SubSysField],
	baggage: &[BaggageField],
) -> Result<proc_macro2::TokenStream> {
	let mut consumes = subsystems.iter().map(|ssf| ssf.consumes.clone().into_iter()).flatten();

	let msg = "Generated message type wrapper";
	let x = quote! {
		#[doc = #msg]
		#[derive(Debug, Clone)]
		enum #messages_wrapper {
			#(
				#consumes ( #consumes ),
			)*
		}
	};
	Ok(x)
}



pub(crate) fn impl_overseer_gen(attr: TokenStream, orig: TokenStream) -> Result<proc_macro2::TokenStream> {
	let args = parse_attr(attr)?;
	let message_wrapper = args.wrapper_enum_name;

	let span = proc_macro2::Span::call_site();
	let ds = parse2::<syn::ItemStruct>(orig.clone())?;
	match ds.fields {
		syn::Fields::Named(named) => {
			let overseer_name = ds.ident.clone();

			// collect the indepedentent subsystem generics
			// which need to be carried along, there are the non-generated ones
			let mut orig_generics = ds.generics;

			// remove default types
			let mut baggage_generic_idents = HashSet::with_capacity(orig_generics.params.len());
			orig_generics.params = orig_generics
				.params
				.into_iter()
				.map(|mut generic| {
					match generic {
						GenericParam::Type(ref mut param) => {
							baggage_generic_idents.insert(param.ident.clone());
							param.eq_token = None;
							param.default = None;
						}
						_ => {}
					}
					generic
				})
				.collect();

			let (subsystems, baggage) = parse_overseer_struct_field(baggage_generic_idents, named)?;

			let mut additive = impl_overseer_struct(overseer_name.clone(), orig_generics, &subsystems, &baggage)?;

			additive.extend(impl_messages_wrapper_enum(message_wrapper, &subsystems[..], &baggage[..])?);
			additive.extend(impl_channels_out_struct(&subsystems[..], &baggage[..])?);
			additive.extend(impl_replacable_subsystem(overseer_name, &subsystems[..], &baggage[..]));

			additive.extend(inc::include_static_rs()?);

			Ok(additive)
		}
		syn::Fields::Unit => Err(Error::new(span, "Must be a struct with named fields. Not an unit struct.")),
		syn::Fields::Unnamed(_) => {
			Err(Error::new(span, "Must be a struct with named fields. Not an unnamed fields struct."))
		}
	}
}
